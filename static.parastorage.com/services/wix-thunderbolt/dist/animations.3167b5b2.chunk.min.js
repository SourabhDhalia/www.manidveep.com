"use strict";
(self.webpackJsonp__wix_thunderbolt_app = self.webpackJsonp__wix_thunderbolt_app || []).push([
    [974], {
        81220: (e, t, i) => {
            i.d(t, {
                Qf: () => r,
                S7: () => c,
                T_: () => o,
                tn: () => s,
                xg: () => n
            });
            const n = e => -(Math.cos(Math.PI * e) - 1) / 2,
                o = e => e < .5 ? 2 * e ** 2 : 1 - (-2 * e + 2) ** 2 / 2,
                s = e => e < .5 ? (1 - Math.sqrt(1 - 4 * e ** 2)) / 2 : (Math.sqrt(-(2 * e - 3) * (2 * e - 1)) + 1) / 2,
                r = {
                    linear: e => e,
                    sineIn: e => 1 - Math.cos(e * Math.PI / 2),
                    sineOut: e => Math.sin(e * Math.PI / 2),
                    sineInOut: n,
                    quadIn: e => e ** 2,
                    quadOut: e => 1 - (1 - e) ** 2,
                    quadInOut: o,
                    cubicIn: e => e ** 3,
                    cubicOut: e => 1 - (1 - e) ** 3,
                    cubicInOut: e => e < .5 ? 4 * e ** 3 : 1 - (-2 * e + 2) ** 3 / 2,
                    quartIn: e => e ** 4,
                    quartOut: e => 1 - (1 - e) ** 4,
                    quartInOut: e => e < .5 ? 8 * e ** 4 : 1 - (-2 * e + 2) ** 4 / 2,
                    quintIn: e => e ** 5,
                    quintOut: e => 1 - (1 - e) ** 5,
                    quintInOut: e => e < .5 ? 16 * e ** 5 : 1 - (-2 * e + 2) ** 5 / 2,
                    expoIn: e => 0 === e ? 0 : 2 ** (10 * e - 10),
                    expoOut: e => 1 === e ? 1 : 1 - 2 ** (-10 * e),
                    expoInOut: e => 0 === e ? 0 : 1 === e ? 1 : e < .5 ? 2 ** (20 * e - 10) / 2 : (2 - 2 ** (-20 * e + 10)) / 2,
                    circIn: e => 1 - Math.sqrt(1 - e ** 2),
                    circOut: e => Math.sqrt(1 - (e - 1) ** 2),
                    circInOut: s,
                    backIn: e => 2.70158 * e ** 3 - 1.70158 * e ** 2,
                    backOut: e => 1 + 2.70158 * (e - 1) ** 3 + 1.70158 * (e - 1) ** 2,
                    backInOut: function(e, t) {
                        return void 0 === t && (t = 2.5949095), e < .5 ? (2 * e) ** 2 * (2 * (t + 1) * e - t) / 2 : ((2 * e - 2) ** 2 * ((t + 1) * (2 * e - 2) + t) + 2) / 2
                    }
                },
                c = {
                    linear: "linear",
                    ease: "ease",
                    easeIn: "ease-in",
                    easeOut: "ease-out",
                    easeInOut: "ease-in-out",
                    sineIn: "cubic-bezier(0.47, 0, 0.745, 0.715)",
                    sineOut: "cubic-bezier(0.39, 0.575, 0.565, 1)",
                    sineInOut: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
                    quadIn: "cubic-bezier(0.55, 0.085, 0.68, 0.53)",
                    quadOut: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
                    quadInOut: "cubic-bezier(0.455, 0.03, 0.515, 0.955)",
                    cubicIn: "cubic-bezier(0.55, 0.055, 0.675, 0.19)",
                    cubicOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
                    cubicInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
                    quartIn: "cubic-bezier(0.895, 0.03, 0.685, 0.22)",
                    quartOut: "cubic-bezier(0.165, 0.84, 0.44, 1)",
                    quartInOut: "cubic-bezier(0.77, 0, 0.175, 1)",
                    quintIn: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
                    quintOut: "cubic-bezier(0.23, 1, 0.32, 1)",
                    quintInOut: "cubic-bezier(0.86, 0, 0.07, 1)",
                    expoIn: "cubic-bezier(0.95, 0.05, 0.795, 0.035)",
                    expoOut: "cubic-bezier(0.19, 1, 0.22, 1)",
                    expoInOut: "cubic-bezier(1, 0, 0, 1)",
                    circIn: "cubic-bezier(0.6, 0.04, 0.98, 0.335)",
                    circOut: "cubic-bezier(0.075, 0.82, 0.165, 1)",
                    circInOut: "cubic-bezier(0.785, 0.135, 0.15, 0.86)",
                    backIn: "cubic-bezier(0.6, -0.28, 0.735, 0.045)",
                    backOut: "cubic-bezier(0.175, 0.885, 0.32, 1.275)",
                    backInOut: "cubic-bezier(0.68, -0.55, 0.265, 1.55)"
                }
        },
        41217: (e, t, i) => {
            i.d(t, {
                Io: () => o,
                Rb: () => r,
                _b: () => n,
                kU: () => s
            });

            function n(e, t, i, n, o) {
                return (o - e) * (n - i) / (t - e) + i
            }

            function o(e, t) {
                let [i, n] = e, [o, s] = t;
                return Math.sqrt((o - i) ** 2 + (s - n) ** 2)
            }

            function s(e) {
                return e * Math.PI / 180
            }

            function r(e, t, i) {
                void 0 === e && (e = [0, 0]), void 0 === t && (t = [0, 0]), void 0 === i && (i = 0);
                return (360 + i + 180 * Math.atan2(t[1] - e[1], t[0] - e[0]) / Math.PI) % 360
            }
        },
        8242: (e, t, i) => {
            function n(e, t) {
                return Object.assign(Object.create(t), e)
            }

            function o(e, t) {
                let i = 0;
                return function() {
                    i && window.clearTimeout(i), i = window.setTimeout((() => {
                        i = 0, e()
                    }), t)
                }
            }

            function s(e, t) {
                return e ? /^-?\d+px$/.test(e) ? parseInt(e) : /^-?\d+[lsd]?vh$/.test(e) ? parseInt(e) * t.viewportHeight / 100 : /^-?\d+[lsd]?vw$/.test(e) ? parseInt(e) * t.viewportWidth / 100 : /^calc\s*\(\s*-?\d+((px)|([lsd]?vh)|([lsd]?vw))\s*\+\s*-?\d+((px)|([lsd]?vh)|([lsd]?vw))\s*\)\s*$/.test(e) ? function(e, t) {
                    const i = e.match(/^calc\s*\(\s*(-?\d+((px)|([lsd]?vh)|([lsd]?vw)))\s*\+\s*(-?\d+((px)|([lsd]?vh)|([lsd]?vw)))\s*\)\s*$/);
                    return s(i[1], t) + s(i[6], t)
                }(e, t) : parseInt(e) || 0 : 0
            }

            function r(e, t, i) {
                const {
                    name: n,
                    offset: o = 0
                } = e, {
                    start: s,
                    end: r
                } = i, c = r - s, u = o / 100;
                let h, f;
                return "entry" === n ? (h = s - t, f = Math.min(t, c)) : "entry-crossing" === n ? (h = s - t, f = c) : "contain" === n ? (h = Math.min(r - t, s), f = Math.abs(t - c)) : "exit" === n ? (h = Math.max(s, r - t), f = Math.min(t, c)) : "exit-crossing" === n ? (h = s, f = c) : "cover" === n && (h = s - t, f = c + t), h + u * f | 0
            }

            function c(e, t, i, n, o) {
                let s = 0;
                const r = {
                    start: t,
                    end: i
                };
                return e.forEach(((t, c) => {
                    s += t.offset;
                    const u = t.sticky;
                    if (u) {
                        if ("end" in u) {
                            const h = e[c - 1] ? .element;
                            if (h) {
                                const e = ((o ? t.element.offsetWidth : t.element.offsetHeight) || 0) + u.end - n,
                                    c = s + e - t.offset,
                                    h = c < r.start;
                                let f = 0;
                                (h || !h && c <= i) && (f = t.offset, r.end += f), h && (r.start += f)
                            }
                        }
                        if ("start" in u) {
                            const i = s - u.start,
                                n = i < r.start,
                                h = !n && i <= r.end;
                            let f = 0;
                            const a = e[c - 1] ? .element;
                            if (a) {
                                if (n || h) {
                                    f = ((o ? a.offsetWidth : a.offsetHeight) || 0) - (t.offset + ((o ? t.element.offsetWidth : t.element.offsetHeight) || 0)), s += f, r.end += f
                                }
                                n && (r.start += f)
                            }
                        }
                    }
                })), r
            }

            function u(e, t, i, n, o, u) {
                const {
                    start: h,
                    end: f,
                    duration: a
                } = e;
                let d, l = h,
                    v = f,
                    p = e.startRange,
                    g = e.endRange;
                if ("string" == typeof a) {
                    p = {
                        name: a,
                        offset: 0
                    }, g = {
                        name: a,
                        offset: 100
                    }, l = r(p, i, t), v = r(g, i, t), d = v - l;
                    const e = c(u, l, v, i, n);
                    l = e.start, v = e.end
                } else {
                    if (p || h ? .name) {
                        p = p || h;
                        const e = s(p.add, o),
                            f = c(u, r({ ...p,
                                offset: 0
                            }, i, t), r({ ...p,
                                offset: 100
                            }, i, t), i, n);
                        l = f.start + p.offset / 100 * (f.end - f.start) + e
                    }
                    if (g || f ? .name) {
                        g = g || f;
                        const e = s(g.add, o),
                            h = c(u, r({ ...g,
                                offset: 0
                            }, i, t), r({ ...g,
                                offset: 100
                            }, i, t), i, n);
                        v = h.start + g.offset / 100 * (h.end - h.start) + e
                    } else "number" == typeof a && (v = l + a)
                }
                return d || a || (d = v - l), { ...e,
                    start: l,
                    end: v,
                    startRange: p,
                    endRange: g,
                    duration: d || a
                }
            }

            function h(e, t, i) {
                return "fixed" === e.position && (!t || t === window.document.body || t === i)
            }

            function f(e, t, i) {
                i && (e.style.position = "static");
                const n = (t ? e.offsetLeft : e.offsetTop) || 0;
                return i && (e.style.position = null), n
            }

            function a(e, t) {
                let i;
                const n = function(e, t) {
                        return parseInt(t ? e.left : e.top)
                    }(e, t),
                    o = function(e, t) {
                        return parseInt(t ? e.right : e.bottom)
                    }(e, t),
                    s = !isNaN(n),
                    r = !isNaN(o);
                return (s || r) && (i = {}, s && (i.start = n), r && (i.end = o)), i
            }

            function d(e, t, i, n, o) {
                const s = e[0].viewSource,
                    r = [];
                let c = (n ? s.offsetWidth : s.offsetHeight) || 0,
                    d = 0,
                    l = s;
                for (; l;) {
                    const e = window.getComputedStyle(l),
                        i = "sticky" === e.position,
                        o = i ? a(e, n) : void 0,
                        s = f(l, n, i);
                    o && "end" in o || (d += s), r.push({
                        element: l,
                        offset: s,
                        sticky: o
                    }), l = l.offsetParent;
                    if (h(e, l, t)) break;
                    if (l === t) {
                        r.push({
                            element: l,
                            offset: 0
                        });
                        break
                    }
                }
                r.reverse();
                return e.map((e => ({ ...u(e, {
                        start: d,
                        end: d + c
                    }, i, n, o, r)
                })))
            }
            i.d(t, {
                O: () => m
            });
            const l = {
                horizontal: !1,
                observeViewportEntry: !0,
                viewportRootMargin: "7% 7%",
                observeViewportResize: !1,
                observeSourcesResize: !1,
                observeContentResize: !1
            };

            function v(e, t, i, n) {
                let o = 0;
                return e >= t && e <= i ? o = n ? (e - t) / n : 1 : e > i && (o = 1), o
            }

            function p(e, t) {
                return e === window ? t ? window.document.documentElement.clientWidth : window.document.documentElement.clientHeight : t ? e.clientWidth : e.clientHeight
            }

            function g(e) {
                const t = n(e, l),
                    i = t.root,
                    s = t.horizontal,
                    r = new WeakMap;
                let c, u, h, f, a, g = p(i, s);
                const w = [],
                    m = {
                        viewportWidth: window.document.documentElement.clientWidth,
                        viewportHeight: window.document.documentElement.clientHeight
                    };
                if (t.scenes = Object.values(e.scenes.reduce(((e, t, i) => {
                        const n = t.groupId ? `group-${t.groupId}` : String(i);
                        return e[n] ? e[n].push(t) : e[n] = [t], e
                    }), {})).flatMap((e => (e.every((e => e.viewSource && ("string" == typeof e.duration || e.start ? .name))) ? (e = d(e, i, g, s, m), (t.observeSourcesResize || t.observeContentResize) && w.push(e)) : e.forEach((e => {
                        null == e.end && (e.end = e.start + e.duration), null == e.duration && (e.duration = e.end - e.start)
                    })), e))), t.scenes.forEach(((e, t) => {
                        e.index = t
                    })), w.length) {
                    const e = new Map;
                    if (window.ResizeObserver && (h = new window.ResizeObserver((function(n) {
                            n.forEach((n => {
                                const o = e.get(n.target),
                                    r = d(o, i, g, s, m);
                                r.forEach(((e, i) => {
                                    t.scenes[e.index] = r[i]
                                })), w.splice(w.indexOf(o), 1, r)
                            }))
                        })), w.forEach((t => {
                            h.observe(t[0].viewSource, {
                                box: "border-box"
                            }), e.set(t[0].viewSource, t)
                        })), t.observeContentResize && t.contentRoot)) {
                        new window.ResizeObserver(o((() => {
                            const n = w.map((e => {
                                const n = d(e, i, g, s, m);
                                return n.forEach(((e, i) => {
                                    t.scenes[e.index] = n[i]
                                })), n
                            }));
                            w.length = 0, w.push(...n), w.forEach((t => {
                                e.set(t[0].viewSource, t)
                            }))
                        }), 100)).observe(t.contentRoot, {
                            box: "border-box"
                        })
                    }
                    t.observeViewportResize && (f = o((function() {
                        g = p(i, s);
                        const n = w.map((e => {
                            const n = d(e, i, g, s, m);
                            return n.forEach(((e, i) => {
                                t.scenes[e.index] = n[i]
                            })), n
                        }));
                        w.length = 0, w.push(...n), w.forEach((t => {
                            e.set(t[0].viewSource, t)
                        }))
                    }), 100), i === window ? window.addEventListener("resize", f) : window.ResizeObserver && (a = new window.ResizeObserver(f), a.observe(i, {
                        box: "border-box"
                    })))
                }
                return t.observeViewportEntry && window.IntersectionObserver && (u = new window.IntersectionObserver((function(e) {
                    e.forEach((e => {
                        (r.get(e.target) || []).forEach((t => {
                            t.disabled = !e.isIntersecting
                        }))
                    }))
                }), {
                    root: i === window ? window.document : i,
                    rootMargin: t.viewportRootMargin,
                    threshold: 0
                }), t.scenes.forEach((e => {
                    if (e.viewSource) {
                        let t = r.get(e.viewSource);
                        t || (t = [], r.set(e.viewSource, t), u.observe(e.viewSource)), t.push(e)
                    }
                }))), {
                    tick: function({
                        p: e,
                        vp: i
                    }) {
                        e = +e.toFixed(1);
                        const n = +i.toFixed(4);
                        if (e !== c) {
                            for (let i of t.scenes)
                                if (!i.disabled) {
                                    const {
                                        start: t,
                                        end: o,
                                        duration: s
                                    } = i, r = v(e, t, o, s);
                                    i.effect(i, r, n)
                                }
                            c = e
                        }
                    },
                    destroy: function() {
                        t.scenes.forEach((e => e.destroy ? .())), u && (u.disconnect(), u = null), h && (h.disconnect(), h = null), f && (a ? (a.disconnect(), a = null) : window.removeEventListener("resize", f))
                    }
                }
            }
            const w = {
                transitionActive: !1,
                transitionFriction: .9,
                transitionEpsilon: 1,
                velocityActive: !1,
                velocityMax: 1
            };
            class m {
                constructor(e = {}) {
                    this.config = n(e, w), this.progress = {
                        p: 0,
                        prevP: 0,
                        vp: 0
                    }, this.currentProgress = {
                        p: 0,
                        prevP: 0,
                        vp: 0
                    }, this._lerpFrameId = 0, this.effect = null;
                    const t = !this.config.root || this.config.root === window.document.body;
                    this.config.root = t ? window : this.config.root, this.config.contentRoot = this.config.contentRoot || (t ? window.document.body : this.config.root.firstElementChild), this.config.resetProgress = this.config.resetProgress || this.resetProgress.bind(this), this._measure = this.config.measure || (() => {
                        const e = this.config.root;
                        this.progress.p = this.config.horizontal ? e.scrollX || e.scrollLeft || 0 : e.scrollY || e.scrollTop || 0
                    }), this._trigger = function(e) {
                        let t = !1;
                        return function() {
                            t || (t = !0, window.requestAnimationFrame((() => {
                                t = !1, e()
                            })))
                        }
                    }((() => {
                        this._measure ? .(), this.tick(!0)
                    }))
                }
                start() {
                    this.setupEffect(), this.setupEvent(), this.resetProgress(), this.tick()
                }
                pause() {
                    this.removeEvent()
                }
                resetProgress(e = {}) {
                    const t = this.config.root,
                        i = e.x || 0 === e.x ? e.x : t.scrollX || t.scrollLeft || 0,
                        n = e.y || 0 === e.y ? e.y : t.scrollY || t.scrollTop || 0,
                        o = this.config.horizontal ? i : n;
                    this.progress.p = o, this.progress.prevP = o, this.progress.vp = 0, this.config.transitionActive && (this.currentProgress.p = o, this.currentProgress.prevP = o, this.currentProgress.vp = 0), e && this.config.root.scrollTo(i, n)
                }
                tick(e) {
                    const t = this.config.transitionActive;
                    t && this.lerp();
                    const i = t ? this.currentProgress : this.progress;
                    if (this.config.velocityActive) {
                        const e = i.p - i.prevP,
                            t = e < 0 ? -1 : 1;
                        i.vp = Math.min(this.config.velocityMax, Math.abs(e)) / this.config.velocityMax * t
                    }
                    this.effect.tick(i), t && i.p !== this.progress.p && (e && this._lerpFrameId && window.cancelAnimationFrame(this._lerpFrameId), this._lerpFrameId = window.requestAnimationFrame((() => this.tick()))), i.prevP = i.p
                }
                lerp() {
                    this.currentProgress.p = function(e, t, i, n) {
                        let o = e * (1 - i) + t * i;
                        if (n) {
                            const i = o - e;
                            Math.abs(i) < n && (o = e + n * Math.sign(i));
                            const s = t - o;
                            if (Math.abs(s) < n) return t
                        }
                        return o
                    }(this.currentProgress.p, this.progress.p, +(1 - this.config.transitionFriction).toFixed(3), this.config.transitionEpsilon)
                }
                destroy() {
                    this.pause(), this.removeEffect()
                }
                setupEvent() {
                    this.removeEvent(), this.config.root.addEventListener("scroll", this._trigger)
                }
                removeEvent() {
                    this.config.root.removeEventListener("scroll", this._trigger)
                }
                setupEffect() {
                    this.removeEffect(), this.effect = g(this.config)
                }
                removeEffect() {
                    this.effect && this.effect.destroy(), this.effect = null
                }
            }
        },
        82634: (e, t, i) => {
            function n(e, t, i) {
                return Math.min(Math.max(e, i), t)
            }

            function o(e) {
                let t = !1;
                return function() {
                    if (!t) return t = !0, window.requestAnimationFrame((() => {
                        t = !1, e()
                    }))
                }
            }

            function s(e) {
                new Promise((e => {
                    const t = window.scrollY;
                    let i, n = !1;

                    function o() {
                        document.body.addEventListener("pointerdown", (e => {
                            void 0 === i ? i = e.offsetY : n = e.offsetY === i
                        }), {
                            once: !0
                        });
                        const e = new PointerEvent("pointerdown", {
                            clientY: 500
                        });
                        document.body.dispatchEvent(e)
                    }
                    o(), window.addEventListener("scroll", (function i() {
                        window.scrollY !== t && (window.removeEventListener("scroll", i), o(), e(n))
                    })), window.scrollY > 0 && window.scrollBy(0, -1)
                })).then((t => {
                    e.fixRequired = t, t && (window.addEventListener("scroll", e.scrollHandler), e.scrollHandler())
                }))
            }
            i.d(t, {
                g: () => v
            });
            let r = 0;
            const c = new Set;

            function u(e, t) {
                if ("onscrollend" in window) return e.addEventListener("scrollend", t),
                    function() {
                        e.removeEventListener("scrollend", t)
                    };
                let i, n = 0;

                function o(e) {
                    clearTimeout(n), n = setTimeout((() => {
                        c.size ? setTimeout(o, 100) : (t(e), n = 0)
                    }), 100)
                }
                return r || (i = function() {
                        const e = e => {
                                for (let t of e.changedTouches) c.add(t.identifier)
                            },
                            t = e => {
                                for (let t of e.changedTouches) c.delete(t.identifier)
                            };
                        return document.addEventListener("touchstart", e, {
                                passive: !0
                            }), document.addEventListener("touchend", t, {
                                passive: !0
                            }),
                            function() {
                                c.clear(), document.removeEventListener("touchstart", e), document.removeEventListener("touchend", t)
                            }
                    }()), r += 1, e.addEventListener("scroll", o),
                    function() {
                        e.removeEventListener("scroll", o), r -= 1, r || i()
                    }
            }

            function h(e, t) {
                this.x = window.scrollX, this.y = window.scrollY, requestAnimationFrame((() => e && e(t)))
            }

            function f(e) {
                e.rect.width = window.document.documentElement.clientWidth, e.rect.height = window.document.documentElement.clientHeight
            }

            function a(e) {
                let t, i, o, s, r, c = !1,
                    a = {
                        x: e.rect.width / 2,
                        y: e.rect.height / 2,
                        vx: 0,
                        vy: 0
                    };
                const d = {
                    x: 0,
                    y: 0
                };
                return e.scenes.forEach((t => {
                    t.target && t.centeredToTarget && (t.transform = function(e, t, i) {
                        return {
                            x(n) {
                                const o = e.left - i.x + e.width / 2,
                                    s = o >= t.width / 2,
                                    r = 2 * (s ? o : t.width - o);
                                return (n - (s ? 0 : o - r / 2)) / r
                            },
                            y(n) {
                                const o = e.top - i.y + e.height / 2,
                                    s = o >= t.height / 2,
                                    r = 2 * (s ? o : t.height - o);
                                return (n - (s ? 0 : o - r / 2)) / r
                            }
                        }
                    }(function(e) {
                        let t = e,
                            i = 0,
                            n = 0;
                        if (t.offsetParent)
                            do {
                                i += t.offsetLeft, n += t.offsetTop, t = t.offsetParent
                            } while (t);
                        return {
                            left: i,
                            top: n,
                            width: e.offsetWidth,
                            height: e.offsetHeight
                        }
                    }(t.target), e.rect, d), c = !0), e.root ? i = function(e) {
                        const t = new ResizeObserver((t => {
                            t.forEach((t => {
                                e.rect.width = t.borderBoxSize[0].inlineSize, e.rect.height = t.borderBoxSize[0].blockSize
                            }))
                        }));
                        return t.observe(e.root, {
                            box: "border-box"
                        }), t
                    }(e) : (o = f.bind(null, e), window.addEventListener("resize", o))
                })), t = function(t) {
                    for (let i of e.scenes)
                        if (!i.disabled) {
                            const o = i.transform ? .x(t.x) || t.x / e.rect.width,
                                s = i.transform ? .y(t.y) || t.y / e.rect.height,
                                r = +n(0, 1, o).toPrecision(4),
                                c = +n(0, 1, s).toPrecision(4),
                                u = {
                                    x: t.vx,
                                    y: t.vy
                                };
                            e.allowActiveEvent && (t.active = o <= 1 && s <= 1 && o >= 0 && s >= 0), i.effect(i, {
                                x: r,
                                y: c
                            }, u, t.active)
                        }
                    Object.assign(a, t)
                }, c && (s = h.bind(d, t, a), r = u(document, s)), {
                    tick: t,
                    destroy: function() {
                        e.scenes.forEach((e => e.destroy ? .())), r ? .(), i ? (i.disconnect(), i = null) : (window.removeEventListener("resize", o), o = null), t = null, a = null
                    }
                }
            }
            let d;
            const l = {
                x: 0,
                y: 0,
                scrollHandler: function() {
                    l.x = window.scrollX, l.y = window.scrollY
                },
                fixRequired: void 0
            };
            class v {
                constructor(e = {}) {
                    let t;
                    this.config = { ...e
                    }, this.effect = null, this._nextTick = null, this._nextTransitionTick = null, this._startTime = 0, t = this.config.transitionDuration ? this.config.noThrottle ? () => this.transition() : o((() => this.transition())) : this.config.noThrottle ? () => (this.tick(), null) : o((() => {
                        this.tick()
                    })), this.config.rect = this.config.root ? {
                        width: this.config.root.offsetWidth,
                        height: this.config.root.offsetHeight
                    } : {
                        width: window.document.documentElement.clientWidth,
                        height: window.document.documentElement.clientHeight
                    }, this.progress = {
                        x: this.config.rect.width / 2,
                        y: this.config.rect.height / 2,
                        vx: 0,
                        vy: 0
                    }, this.previousProgress = { ...this.progress
                    }, this.currentProgress = null;
                    const i = e => {
                        const i = this.config.root ? e.offsetX : e.x,
                            n = this.config.root ? e.offsetY : e.y;
                        this.progress.vx = i - this.progress.x, this.progress.vy = n - this.progress.y, this.progress.x = i, this.progress.y = n, this._nextTick = t()
                    };
                    if (this._pointerLeave = () => {
                            this.progress.active = !1, this.progress.vx = 0, this.progress.vy = 0, this._nextTick = t()
                        }, this._pointerEnter = () => {
                            this.progress.active = !0, this._nextTick = t()
                        }, this.config.root) {
                        d = "boolean" == typeof d ? d : function() {
                            const e = window.devicePixelRatio;
                            let t = !1;
                            if (1 === e) return !1;
                            document.body.addEventListener("pointerdown", (e => {
                                t = 10 !== e.offsetX
                            }), {
                                once: !0
                            });
                            const i = new PointerEvent("pointerdown", {
                                clientX: 10
                            });
                            return document.body.dispatchEvent(i), t
                        }();
                        const e = d ? window.devicePixelRatio : 1;
                        void 0 === l.fixRequired && s(l), this._measure = t => {
                            if (t.target !== this.config.root) {
                                const i = new PointerEvent("pointermove", {
                                    bubbles: !0,
                                    cancelable: !0,
                                    clientX: t.x * e + l.x,
                                    clientY: t.y * e + l.y
                                });
                                t.stopPropagation(), this.config.root.dispatchEvent(i)
                            } else i(t)
                        }
                    } else this._measure = i
                }
                start() {
                    this.setupEffect(), this.setupEvent()
                }
                pause() {
                    this.removeEvent()
                }
                tick() {
                    this.effect.tick(this.progress)
                }
                transition() {
                    const e = this.config.transitionDuration,
                        t = this.config.transitionEasing || (e => e),
                        i = performance.now();
                    let n = !1;
                    const o = i => {
                        const s = (i - this._startTime) / e,
                            r = t(Math.min(1, s));
                        n && (this.progress.vx = 0, this.progress.vy = 0, n = !1), this.currentProgress = Object.entries(this.progress).reduce(((e, [t, i]) => (e[t] = "active" === t ? i : this.previousProgress[t] + (i - this.previousProgress[t]) * r, e)), this.currentProgress || {}), s < 1 && (this._nextTransitionTick = requestAnimationFrame(o), n = i - this._startTime > 50), this.effect.tick(this.currentProgress)
                    };
                    return this._startTime ? (this._nextTransitionTick && cancelAnimationFrame(this._nextTransitionTick), Object.assign(this.previousProgress, this.currentProgress), this._startTime = i, o(i)) : this._startTime = i, this._nextTransitionTick
                }
                destroy() {
                    this.pause(), this.removeEffect(), this._nextTick && cancelAnimationFrame(this._nextTick), this._nextTransitionTick && cancelAnimationFrame(this._nextTransitionTick)
                }
                setupEvent() {
                    this.removeEvent();
                    const e = this.config.root || window;
                    e.addEventListener("pointermove", this._measure, {
                        passive: !0
                    }), this.config.eventSource && this.config.eventSource.addEventListener("pointermove", this._measure, {
                        passive: !0
                    }), this.config.allowActiveEvent && (e.addEventListener("pointerleave", this._pointerLeave, {
                        passive: !0
                    }), e.addEventListener("pointerenter", this._pointerEnter, {
                        passive: !0
                    }), this.config.eventSource && (this.config.eventSource.addEventListener("pointerleave", this._pointerLeave, {
                        passive: !0
                    }), this.config.eventSource.addEventListener("pointerenter", this._pointerEnter, {
                        passive: !0
                    })))
                }
                removeEvent() {
                    const e = this.config.root || window;
                    e.removeEventListener("pointermove", this._measure), this.config.eventSource && this.config.eventSource.removeEventListener("pointermove", this._measure), this.config.allowActiveEvent && (e.removeEventListener("pointerleave", this._pointerLeave), e.removeEventListener("pointerenter", this._pointerEnter), this.config.eventSource && (this.config.eventSource.removeEventListener("pointerleave", this._pointerLeave), this.config.eventSource.removeEventListener("pointerenter", this._pointerEnter)))
                }
                setupEffect() {
                    this.removeEffect(), this.effect = a(this.config)
                }
                removeEffect() {
                    this.effect && this.effect.destroy(), this.effect = null
                }
            }
        }
    }
]);
//# sourceMappingURL=https://static.parastorage.com/services/wix-thunderbolt/dist/animations.3167b5b2.chunk.min.js.map